// Adding this comment to enforce the change 
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Piano Gym — Note Identification (MIDI)</title>

  <!-- VexFlow (SVG) -->
  <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.5/releases/vexflow-min.js"></script>

  <style>
    body { font-family: system-ui, Arial; padding: 16px; max-width: 980px; margin: 0 auto; }
    h1 { margin: 6px 0 14px; }
    button, select, input[type="checkbox"] { font-size: 16px; }
    button, select { padding: 10px; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin: 12px 0; }
    .big { font-size: 26px; margin: 10px 0; }
    .ok { color: #1b7f2a; font-weight: 700; }
    .bad { color: #b00020; font-weight: 700; }
    .muted { opacity: 0.75; }
    .card { border: 1px solid #ddd; border-radius: 14px; padding: 12px; margin-top: 12px; }

    .layout { display: grid; grid-template-columns: 320px 1fr; gap: 14px; align-items: start; }
    @media (max-width: 860px) { .layout { grid-template-columns: 1fr; } }

    .panelTitle { font-weight: 700; font-size: 18px; margin-bottom: 6px; }
    .panelItem { display: grid; grid-template-columns: 1fr; gap: 6px; padding: 10px; border: 1px solid #eee; border-radius: 12px; margin-bottom: 10px; }
    .panelItem label { font-weight: 600; }
    .inline { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .chip { display:inline-flex; gap:8px; align-items:center; padding: 6px 10px; border: 1px solid #eee; border-radius: 999px; }
    #staff { border: 1px solid #eee; border-radius: 14px; padding: 8px; }
  </style>
</head>

<body>
  <h1>Piano Gym — Note Identification</h1>

  <div class="row">
    <button id="btnEnable">Enable MIDI</button>

    <select id="midiInputs" disabled>
      <option value="">(no inputs yet)</option>
    </select>

    <button id="btnNew">New Note</button>

    <button id="btnShowAnswer">Show answer</button>
    <button id="btnHideAnswer">Hide</button>
  </div>

  <div class="layout">
    <!-- Customize panel -->
    <div class="card">
      <div class="panelTitle">Customize</div>

      <div class="panelItem">
        <label>Clefs</label>
        <select id="clefs">
          <option value="treble">Treble</option>
          <option value="bass">Bass</option>
          <option value="grand" selected>Grand (Treble + Bass)</option>
        </select>
      </div>

      <div class="panelItem">
        <label>Treble Range</label>
        <div class="inline">
          <div>
            <div class="muted" style="font-size:13px;">Min</div>
            <select id="trebleMin"></select>
          </div>
          <div>
            <div class="muted" style="font-size:13px;">Max</div>
            <select id="trebleMax"></select>
          </div>
        </div>
      </div>

      <div class="panelItem">
        <label>Bass Range</label>
        <div class="inline">
          <div>
            <div class="muted" style="font-size:13px;">Min</div>
            <select id="bassMin"></select>
          </div>
          <div>
            <div class="muted" style="font-size:13px;">Max</div>
            <select id="bassMax"></select>
          </div>
        </div>
      </div>

      <div class="panelItem">
        <label>Positions</label>
        <select id="positions">
          <option value="all" selected>All (lines + spaces)</option>
          <option value="lines">Lines only</option>
          <option value="spaces">Spaces only</option>
        </select>
      </div>

      <div class="panelItem">
        <label>Note Values (visual)</label>
        <div class="inline">
          <label class="chip"><input type="checkbox" id="valQ" checked> Quarter</label>
          <label class="chip"><input type="checkbox" id="valH" checked> Half</label>
          <label class="chip"><input type="checkbox" id="valW" checked> Whole</label>
        </div>
        <div class="muted" style="font-size:13px;">
          We don’t grade duration; it’s only what you see.
        </div>
      </div>

      <div class="panelItem">
        <label>Accidentals</label>
        <div class="inline">
          <label class="chip"><input type="checkbox" id="accOn"> Enable sharps (#)</label>
        </div>
      </div>

      <div class="panelItem">
        <label>Dev keyboard mapping</label>
        <div class="muted" style="font-size:13px; line-height:1.35;">
          a=C4, s=D4, d=E4, f=F4, g=G4, h=A4, j=B4, k=C5<br/>
          (Useful in coffee shop without piano)
        </div>
      </div>

      <div class="muted" style="font-size:13px;">
        Tip: After changing settings, it auto-generates a new note.
      </div>
    </div>

    <!-- Exercise / staff -->
    <div>
      <div id="staff"></div>

      <div class="card" id="answerCard" style="display:none;">
        <div>Target answer:</div>
        <div class="big" id="targetAnswer">—</div>
      </div>

      <div class="card">
        <div>You played:</div>
        <div class="big" id="played">—</div>
        <div class="big" id="result"></div>
        <div id="debug" class="muted"></div>
      </div>
    </div>
  </div>

<script>
  // =========================================================
  // NOTE + MIDI UTILS
  // =========================================================
  const NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];

  function midiToNoteName(midi) {
    const name = NOTE_NAMES[midi % 12];
    const octave = Math.floor(midi / 12) - 1; // 60=C4
    return `${name}${octave}`;
  }

  function noteNameToMidi(note) {
    // Supports naturals + sharps, single-digit octave (enough for our ranges)
    // Ex: "C4", "F#3"
    const m = note.match(/^([A-G])(#?)(-?\d+)$/);
    if (!m) return null;
    const letter = m[1];
    const sharp = m[2] === "#";
    const octave = parseInt(m[3], 10);
    const base = {C:0,D:2,E:4,F:5,G:7,A:9,B:11}[letter];
    const pitch = base + (sharp ? 1 : 0);
    return (octave + 1) * 12 + pitch;
  }

  function isNaturalMidi(m) { return !NOTE_NAMES[m % 12].includes("#"); }

  // =========================================================
  // CONFIG + RANGE OPTIONS (simple, beginner-friendly)
  // =========================================================
  // We'll offer a curated set of range endpoints (like musicTheory.net-ish)
  // Treble common: A3..C6 ; Bass common: E1..C4
  const RANGE_NOTES = [
    "E1","F1","G1","A1","B1",
    "C2","D2","E2","F2","G2","A2","B2",
    "C3","D3","E3","F3","G3","A3","B3",
    "C4","D4","E4","F4","G4","A4","B4",
    "C5","D5","E5","F5","G5","A5","B5",
    "C6"
  ];

  function fillRangeSelect(sel, defaultValue) {
    sel.innerHTML = "";
    for (const n of RANGE_NOTES) {
      const opt = document.createElement("option");
      opt.value = n;
      opt.textContent = n;
      sel.appendChild(opt);
    }
    sel.value = defaultValue;
  }

  // =========================================================
  // STAFF POSITION FILTER (lines/spaces)
  // =========================================================
  // We’ll filter based on the note’s staff position (line vs space) in its clef.
  // Approach: map each natural letter to a diatonic index; compare parity from clef’s reference line.
  // Treble reference: E4 is bottom line.
  // Bass reference: G2 is bottom line.
  const DIATONIC_INDEX = { C:0, D:1, E:2, F:3, G:4, A:5, B:6 };

  function diatonicNumber(noteName) {
    // noteName: "F#3" or "E4"
    const m = noteName.match(/^([A-G])(#?)(-?\d+)$/);
    if (!m) return null;
    const letter = m[1];
    const octave = parseInt(m[3], 10);
    // Each octave adds 7 diatonic steps
    return octave * 7 + DIATONIC_INDEX[letter];
  }

  function isLinePosition(noteName, clef) {
    // bottom line parity check relative to reference note
    const ref = (clef === "bass") ? "G2" : "E4";
    const dn = diatonicNumber(noteName);
    const dr = diatonicNumber(ref);
    if (dn == null || dr == null) return true;

    const diff = dn - dr; // 0 = bottom line
    // lines: even steps from bottom line (0,2,4..) ; spaces: odd (1,3,5..)
    return (diff % 2 === 0);
  }

  // =========================================================
  // VEXFLOW RENDERING
  // =========================================================
  function getVF() {
    if (window.Vex && window.Vex.Flow) return window.Vex.Flow;
    if (window.VexFlow) return window.VexFlow;
    return null;
  }

  function noteToVexKey(note) {
    // "C4" -> "c/4", "F#3" -> "f#/3"
    const m = note.match(/^([A-G])(#?)(-?\d+)$/);
    if (!m) return "c/4";
    const letter = m[1].toLowerCase();
    const sharp = m[2] === "#" ? "#" : "";
    const octave = m[3];
    return `${letter}${sharp}/${octave}`;
  }

  function clefForNote(note) {
    // simple split: C4 and above treble, below bass
    const midi = noteNameToMidi(note);
    if (midi == null) return "treble";
    return midi >= 60 ? "treble" : "bass";
  }

  function beatsForDuration(d) {
    if (d === "w") return 4;
    if (d === "h") return 2;
    return 1; // q
  }

  function drawNoteOnGrandStaff(note, duration, showGrand /*bool*/) {
    const VF = getVF();
    const staffDiv = document.getElementById("staff");
    staffDiv.innerHTML = "";
    if (!VF) {
      staffDiv.textContent = "VexFlow failed to load. MIDI still works.";
      return;
    }

    try {
      const renderer = new VF.Renderer(staffDiv, VF.Renderer.Backends.SVG);
      renderer.resize(820, 240);
      const ctx = renderer.getContext();

      const treble = new VF.Stave(10, 20, 780).addClef("treble");
      const bass   = new VF.Stave(10, 140, 780).addClef("bass");
      treble.setContext(ctx).draw();
      bass.setContext(ctx).draw();

      new VF.StaveConnector(treble, bass).setType(VF.StaveConnector.type.BRACE).setContext(ctx).draw();
      new VF.StaveConnector(treble, bass).setType(VF.StaveConnector.type.SINGLE_LEFT).setContext(ctx).draw();
      new VF.StaveConnector(treble, bass).setType(VF.StaveConnector.type.SINGLE_RIGHT).setContext(ctx).draw();

      const beats = beatsForDuration(duration);

      const clef = showGrand ? clefForNote(note) : (document.getElementById("clefs").value === "bass" ? "bass" : "treble");
      const stave = (clef === "bass") ? bass : treble;

      const keys = [noteToVexKey(note)];
      const sn = new VF.StaveNote({ clef, keys, duration });

      // Add accidental if needed
      if (note.includes("#")) {
        sn.addModifier(new VF.Accidental("#"), 0);
      }

      const voice = new VF.Voice({ num_beats: beats, beat_value: 4 });
      voice.setStrict(false);
      voice.addTickables([sn]);

      new VF.Formatter().joinVoices([voice]).format([voice], 500);
      voice.draw(ctx, stave);

    } catch (err) {
      console.error("VexFlow render error:", err);
      staffDiv.textContent = "VexFlow render error (check console). MIDI still works.";
    }
  }

  // =========================================================
  // ENGINE
  // =========================================================
  const Engine = {
    target: null,
    duration: "q",
    locked: false,

    getConfig() {
      const clefs = document.getElementById("clefs").value;           // treble|bass|grand
      const trebleMin = document.getElementById("trebleMin").value;
      const trebleMax = document.getElementById("trebleMax").value;
      const bassMin = document.getElementById("bassMin").value;
      const bassMax = document.getElementById("bassMax").value;

      const positions = document.getElementById("positions").value;   // all|lines|spaces
      const accOn = document.getElementById("accOn").checked;

      const noteValues = [];
      if (document.getElementById("valQ").checked) noteValues.push("q");
      if (document.getElementById("valH").checked) noteValues.push("h");
      if (document.getElementById("valW").checked) noteValues.push("w");

      return { clefs, trebleMin, trebleMax, bassMin, bassMax, positions, accOn, noteValues };
    },

    pickDuration(noteValues) {
      if (!noteValues.length) return "q";
      return noteValues[Math.floor(Math.random() * noteValues.length)];
    },

    randomNoteFromClefRange(clef, cfg) {
      const min = noteNameToMidi(clef === "treble" ? cfg.trebleMin : cfg.bassMin);
      const max = noteNameToMidi(clef === "treble" ? cfg.trebleMax : cfg.bassMax);
      if (min == null || max == null) return "C4";

      // Ensure min <= max
      const lo = Math.min(min, max);
      const hi = Math.max(min, max);

      for (let tries = 0; tries < 400; tries++) {
        const m = lo + Math.floor(Math.random() * (hi - lo + 1));
        const name = midiToNoteName(m);

        // Accidentals
        if (!cfg.accOn && name.includes("#")) continue;

        // Positions filter (lines/spaces) — treat the note in the selected clef
        const line = isLinePosition(name, clef);
        if (cfg.positions === "lines" && !line) continue;
        if (cfg.positions === "spaces" && line) continue;

        return name;
      }

      // Fallback: just pick a natural note in range
      for (let tries = 0; tries < 400; tries++) {
        const m = lo + Math.floor(Math.random() * (hi - lo + 1));
        if (!isNaturalMidi(m)) continue;
        return midiToNoteName(m);
      }
      return midiToNoteName(lo);
    },

    newChallenge() {
      const cfg = this.getConfig();
      this.duration = this.pickDuration(cfg.noteValues);
      this.locked = false;

      // choose clef(s)
      let chosenClef = "treble";
      if (cfg.clefs === "treble") chosenClef = "treble";
      else if (cfg.clefs === "bass") chosenClef = "bass";
      else chosenClef = (Math.random() < 0.5) ? "treble" : "bass"; // grand

      this.target = this.randomNoteFromClefRange(chosenClef, cfg);

      // UI reset
      document.getElementById("answerCard").style.display = "none";
      document.getElementById("targetAnswer").textContent = "—";
      document.getElementById("played").textContent = "—";
      setResult("", "");

      // Render
      drawNoteOnGrandStaff(this.target, this.duration, cfg.clefs === "grand");

      document.getElementById("debug").textContent =
        `Target clef=${chosenClef} | Positions=${cfg.positions} | Accidentals=${cfg.accOn ? "on" : "off"} | Value=${this.duration}`;
    },

    revealAnswer() {
      if (!this.target) return;
      document.getElementById("targetAnswer").textContent = `${this.target} (${this.duration})`;
      document.getElementById("answerCard").style.display = "block";
    },

    hideAnswer() {
      document.getElementById("answerCard").style.display = "none";
    },

    handlePlayed(noteName) {
      if (!this.target) return;

      document.getElementById("played").textContent = noteName;

      // Grade: pitch match only
      const correct = (noteName === this.target);

      if (correct) {
        if (this.locked) return;
        this.locked = true;
        setResult("✅ Correct", "ok");
        setTimeout(() => this.newChallenge(), 450);
      } else {
        setResult("❌ Wrong", "bad");
      }
    }
  };

  // =========================================================
  // RESULT UI HELPER
  // =========================================================
  function setResult(text, cls) {
    const el = document.getElementById("result");
    el.textContent = text;
    el.className = cls ? `big ${cls}` : "big";
  }

  // =========================================================
  // MIDI WIRING
  // =========================================================
  const btnEnable = document.getElementById("btnEnable");
  const selInputs = document.getElementById("midiInputs");

  let midiAccess = null;
  let activeInput = null;

  function populateInputs() {
    const inputs = Array.from(midiAccess.inputs.values());
    selInputs.innerHTML = "";

    if (inputs.length === 0) {
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(no MIDI inputs found)";
      selInputs.appendChild(opt);
      selInputs.disabled = true;
      return;
    }

    for (const input of inputs) {
      const opt = document.createElement("option");
      opt.value = input.id;
      opt.textContent = input.name || `Input ${input.id}`;
      selInputs.appendChild(opt);
    }
    selInputs.disabled = false;
  }

  function detachActive() {
    if (activeInput) activeInput.onmidimessage = null;
    activeInput = null;
  }

  function attachToInput(inputId) {
    detachActive();
    const input = midiAccess.inputs.get(inputId);
    if (!input) return;

    activeInput = input;
    activeInput.onmidimessage = (msg) => {
      const [status, data1, data2] = msg.data;
      const cmd = status & 0xF0;
      const isNoteOn = (cmd === 0x90 && data2 > 0);
      if (!isNoteOn) return;
      Engine.handlePlayed(midiToNoteName(data1));
    };

    document.getElementById("debug").textContent = `Listening to: ${activeInput.name || activeInput.id}`;
  }

  function pickDefaultInput() {
    const inputs = Array.from(midiAccess.inputs.values());
    if (inputs.length === 0) return;

    const preferred = inputs.find(i => /fp|roland/i.test(i.name || ""));
    const chosen = preferred || inputs[0];
    selInputs.value = chosen.id;
    attachToInput(chosen.id);
  }

  btnEnable.addEventListener("click", async () => {
    if (!navigator.requestMIDIAccess) {
      alert("WebMIDI not supported. Use Chrome (desktop).");
      return;
    }
    try {
      midiAccess = await navigator.requestMIDIAccess({ sysex: false });
      populateInputs();
      pickDefaultInput();

      midiAccess.onstatechange = () => {
        populateInputs();
        if (activeInput && !midiAccess.inputs.get(activeInput.id)) {
          detachActive();
          pickDefaultInput();
        }
      };

      btnEnable.disabled = true;
      btnEnable.textContent = "MIDI Enabled";
    } catch (e) {
      console.error(e);
      alert("Could not enable MIDI. Check permissions and USB connection.");
    }
  });

  selInputs.addEventListener("change", () => {
    if (!midiAccess) return;
    const id = selInputs.value;
    if (id) attachToInput(id);
  });

  // =========================================================
  // BUTTONS + CUSTOMIZE AUTO-REFRESH
  // =========================================================
  document.getElementById("btnNew").addEventListener("click", () => Engine.newChallenge());
  document.getElementById("btnShowAnswer").addEventListener("click", () => Engine.revealAnswer());
  document.getElementById("btnHideAnswer").addEventListener("click", () => Engine.hideAnswer());

  // Auto-generate a new note whenever config changes
  const cfgIds = ["clefs","trebleMin","trebleMax","bassMin","bassMax","positions","valQ","valH","valW","accOn"];
  for (const id of cfgIds) {
    document.getElementById(id).addEventListener("change", () => Engine.newChallenge());
  }

  // =========================================================
  // DEV KEYBOARD INPUT (coffee shop)
  // =========================================================
  const KEYMAP = { a:"C4", s:"D4", d:"E4", f:"F4", g:"G4", h:"A4", j:"B4", k:"C5" };
  window.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    if (tag === "INPUT" || tag === "SELECT" || tag === "TEXTAREA") return;

    const key = e.key.toLowerCase();
    const mapped = KEYMAP[key];
    if (mapped) {
      e.preventDefault();
      Engine.handlePlayed(mapped);
    }
  });

  // =========================================================
  // INIT RANGE DROPDOWNS + START
  // =========================================================
  fillRangeSelect(document.getElementById("trebleMin"), "C4");
  fillRangeSelect(document.getElementById("trebleMax"), "C6");
  fillRangeSelect(document.getElementById("bassMin"), "E2");
  fillRangeSelect(document.getElementById("bassMax"), "C4");

  // Ensure mins <= maxs visually (simple guard)
  function clampRanges() {
    const tMin = noteNameToMidi(document.getElementById("trebleMin").value);
    const tMax = noteNameToMidi(document.getElementById("trebleMax").value);
    if (tMin != null && tMax != null && tMin > tMax) document.getElementById("trebleMax").value = document.getElementById("trebleMin").value;

    const bMin = noteNameToMidi(document.getElementById("bassMin").value);
    const bMax = noteNameToMidi(document.getElementById("bassMax").value);
    if (bMin != null && bMax != null && bMin > bMax) document.getElementById("bassMax").value = document.getElementById("bassMin").value;
  }
  for (const id of ["trebleMin","trebleMax","bassMin","bassMax"]) {
    document.getElementById(id).addEventListener("change", clampRanges);
  }

  Engine.newChallenge();
</script>
</body>

</html>
